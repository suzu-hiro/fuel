<html lang="ja">
  <head>
    <meta charset="utf8" />
    <meta name="robots" content="noindex">
    <title>suzu-hiro note</title>
    <link rel="shortcut icon" href="../../../favicon.png">
    <link rel="stylesheet" type="text/css" href="../../assets/css/common.css">
    <link href="../../lib/prism/prism.css" rel="stylesheet" /> 
  </head>
  <body>
  <body>
    <h1 class="title">SELECT 1<a href="../../">TOP</a></h1>
    <main>
      <section>
        <h2>集計する範囲を変える</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT CASE pref
          WHEN '徳島' THEN '四国'
          WHEN '香川' THEN '四国'
          WHEN '福岡' THEN '九州'
          WHEN '佐賀' THEN '九州'
          ELSE 'その他' END AS district,
          sum(population)
 FROM poptbl
GROUP BY CASE pref
           WHEN '徳島' THEN '四国'
           WHEN '香川' THEN '四国'
           WHEN '福岡' THEN '九州'
           WHEN '佐賀' THEN '九州'
           ELSE 'その他' END
-- SQL標準違反だが、MySQLは、GROUP BY district と表現しても動作する</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>order by でソート列を作る</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT key 
 FROM greatests
order by CASE key WHEN 'B' THEN 1
                 WHEN 'A' THEN 2
                 WHEN 'D' THEN 3
                 ELSE null END</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>自己結合による組み合わせ</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">-- 重複順列
SELECT p1.name AS n1, p2.name AS n2
 FROM products p1, products p2
-- 順列 (同一要素の組み合わせを排除)
SELECT p1.name AS n1, p2.name AS n2
 FROM products p1, product p2
WHERE p1.name &lt;&gt; p2.name
-- 組み合わせ (順序を入れ替えた組み合わせの排除)
SELECT p1.name AS n1, p2.name AS n2
 FROM products p1, products p2
WHERE p1.name &gt; p2.name
-- 組み合わせ3列
SELECT p1.name AS n1, p2.name AS n2, p3.name AS n3
 FROM products p1, products p2, products p3
WHERE p1.name &gt; p2.name AND p2.name &gt; p3.name</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>部分的に不一致なキーの検索</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT DISTINCT a1.name, a2.address 
  FROM addresses a1, addresses a2
WHERE a1.family_id = a2.family_id AND a1.address &lt;&gt; a2.address</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>限定述語と極値関数</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">-- 限定述語
--   東京の生徒の誰よりも若い
SELECT * FROM class_a
WHERE age &lt; ALL ( SELECT age FROM class_b WHERE city = '東京'
-- 極値関数
--   東京の最も若い生徒よりも若い
SELECT * FROM class_a 
WHERE age &lt; ( SELECT MIN(age) FROM class_b WHERE city = '東京' )
-- class_b に東京の生徒がいない場合、
--    all は全行返すが、 極値関数は、NULLを返す</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>ランキング</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT p1.name, p1.price,
      ( SELECT COUNT(p2.price) 
        FROM products p2
         WHERE p2.price &gt; p1.price) + 1 AS rank_1
 FROM products p1 ;
----------------------------
SELECT p1.name, MAX(p1.price) AS price, COUNT(p2.name) + 1 AS rank_1
 FROM products p1
 LEFT OUTER JION products p2 ON p1.price &lt; p2.price
GROUP BY p1.name 
-- INNER JION にすると１位が除外される</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>歯抜けの最小値</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT MIN(seq + 1) 
  FROM seqtbl
WHERE (seq + 1) NOT IN (SELECT seq FROM seqtbl )</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>最頻値</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT income, COUNT(*)
  FROM graduates
 GROUP BY income
HAVING COUNT(*) &gt;= all ( SELECT COUNT(*) 
                       FROM graduates
                       GROUP BY income)
--------------------------------------
SELECT income, COUNT(*)
  FROM graduates
GROUP BY income
HAVING COUNT(*) &gt;= ( SELECT MAX(cnt)
                       FROM ( SELECT COUNT(*) AS cnt
                            FROM graduates
                             GROUP BY income) tmp
                       )</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>メジアン</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT AVG(DISTINCT income)
  -- 偶数の場合は、2つ抽出されるためAVG
  FROM (
     SELECT t1.income
      FROM graduates t1, graduates t2
     GROUP BY t1.income
     HAVING SUM(CASE WHEN t2.income &gt;= t1.income THEN 1 ELSE 0 END) &gt;= COUNT(*) / 2
      AND SUM( CASE WHEN  t2.income &lt;= t1.income THEN 1 ELSE 0 END) &gt;= COUNT(*) / 2
  ) tmp
-- income の上位と下位の集合の個数が、全体の半分
-- になる場合の、incomeを抽出する</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>商品をすべて置いている店舗（余分な商品を許容する）</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT si.shop
  FROM shopitems si, items i
WHERE si.item = i.item
GROUP BY si.shop
HAVING COUNT( si.item ) = ( SELECT COUNT(item) FROM items) ;
-- HAVINGの右側は、COUNT(i.item)だと正しくない
-- 結合により、元のテーブルの行数と変わっているため</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>商品を過不足なく置いている店舗（厳密な関係除算）</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT si.shop
 FROM shopitems si LEFT OUTER JION items
    ON si.item = i.item
GROUP BY si.shop
HAVING COUNT( si.item) = ( SELECT COUNT(item) FROM items)
AND COUNT( i.item ) = ( SELECT COUNT(item) FROM items);
-- 外部結合により、店舗の商品が余分な場合は、条件に合わなくなる</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>行列変換  (スカラサブクエリ)  (集約)</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">SELECT c0.name,
  (SELECT '○' FROM courses c1
   WHERE course = 'SQL入門' AND c1.name = c0.name) AS "SQL入門",
  (SELECT '○' FROM courses c2
   WHERE course = 'UNIX基礎' AND c2.name = c0.name) AS "UNIX基礎"
 FROM ( SELECT DISTINCT name FROM courses) c0
--------------------------------
SELECT name,
  CASE WHEN SUM(CASE WHEN course = 'SQL入門' THEN 1 ELSE null END  ) = 1
       THEN '○' ELSE null END  AS "SQL入門",
  CASE WHEN SUM(CASE WHEN course = 'UNIX基礎' THEN 1 ELSE null END  ) = 1
       THEN '○' ELSE null END  AS "UNIX基礎"
 FROM courses
GROUP BY name</code></pre>
          </div>
        </div>
      </section>
      <section>
        <h2>掛け算としての結合</h2>
        <div class="content">
          <div class="code">
            <pre><code class="language-sql">-- その１ 結合の前に集約し 1対1 を作る
SELECT i.item_no, sh.total_qty
 FROM items i 
LEFT OUTER JION
  ( SELECT item_no, sum(guantity) AS total_qty
      FROM saleshistory
     GROUP BY item_no ) sh
  ON i.item_no = sh.item_no
-- その2 集約の前に、1対多の結合を行う
SELECT i.item_no, sum(sh.quantity) AS total_qty
 FROM item i 
LEFT OUTER JION saleshistory sh
 ON i.item_no = sh.item_no
GROUP BY i.item_no
-- その2の方が、中間テーブルを作成しないのでパフォーマンスがよい</code></pre>
          </div>
        </div>
      </section>
    </main>
    <script src="../../lib/prism/prism.js"></script>
  </body>
</html>